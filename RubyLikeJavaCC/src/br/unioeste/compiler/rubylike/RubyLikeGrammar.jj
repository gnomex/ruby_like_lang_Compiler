/**
 * JavaCC template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */options{  JDK_VERSION = "1.5";  static = false;
  LOOKAHEAD = 2;
  DEBUG_PARSER = false;}PARSER_BEGIN(RubyLikeGrammar)package br.unioeste.compiler.rubylike;

import java.io.*;
import java.util.*;
import br.unioeste.compiler.recovery.*;

public class RubyLikeGrammar{
    int contParseError; // Contador de erros sintáticos
    boolean debug_recovery; // Controla a verbose de recuperação de erros

    Hashtable tbl = new Hashtable ();
      public static void main(String args []) throws ParseException  {
    boolean debug_as = false;
    boolean debug_recovery = false;
    RubyLikeGrammar parser = new RubyLikeGrammar(System.in);

    parser.debug_recovery = debug_recovery;
    
    if (!debug_as) parser.disable_tracing();
        int b=1;
    while (b==1) {
      System.out.println("Lendo da entrada padrão...");
      System.out.print("Expressão \"1+(2+3)*4;\" ou atribuição :");
      try {
        b = parser.program();
        switch (b) {
          case 0 :  System.out.println("Goodbye.");
                    break;
          case 1 :  System.out.println("OK.");
                    break;
          default : break;
        }
      }
      catch (ParseException e) {
        System.out.println("NOK.");
        System.out.println(e.getMessage());
        parser.ReInit(System.in);
      }
      catch (Exception e) {
        System.out.println("NOK.");
        System.out.println(e.getMessage());
        parser.ReInit(System.in);
      }
      catch (Error e) {
        System.out.println("Oops.");
        System.out.println(e.getMessage());
        break;
      }
    }  }

  void mostrarResult ( double a )
  {
 	//this.erros.append ( Double.toString ( a ) );
  } 

  // Relaciona o indice de um token com seu nome
  static public String im ( int x ) {
    int k;
    String s;
    s = tokenImage[x];
    k = s.lastIndexOf ( "\"");
    try {
      s = s.substring ( 1, k );
    } catch ( StringIndexOutOfBoundsException e ) { }
    return s;
  }

  boolean eof; // Variável que indica se EOF foi alcançado
  // O método abaixo consome os tokens até alcançar um que pertença
  // ao conjunto de resincronização
  void consumeUntil ( RecoverySet g,
                      ParseException e,
                      String met ) throws ParseEOFException, ParseException  {
     Token tok;
     eof=false; // FIXME
     if (debug_recovery) { // Informação sobre a recuperação
       //erros.append("");
       //erros.append( "*** " + met + " *** ");
       //erros.append( " Syncronizing Set: "+ g );
     }
     if (g==null) throw e; // se o conjunto de recuperação é null, propaga a exceção

     tok = getToken ( 1 ); // pega o token atual
     while (!eof) {
       if ( g.contains ( tok.kind ) ) {
         if ( debug_recovery )
           //erros.append( " Found syncronizing token: " + im (tok.kind));
         break;
       }
       if (debug_recovery)
         //erros.append( " Ignorando token "+ im ( tok.kind));
       getNextToken();
       tok = getToken(1);
       if (tok.kind==EOF && !g.contains(EOF) )
         eof = true;
     }
     System.out.println ( e.getMessage());
     contParseError++;
     if ( eof ) throw new ParseException ( "EOF found prematurely.");
   }
   }PARSER_END(RubyLikeGrammar)SKIP :{  " "| "\r"| "\t"| "\n"
| "\f"
| "#" : singlelinecomment
| "/*" : multilinecomment}
< singlelinecomment > SKIP :
{
  < ["\n","\r"] > : DEFAULT
| < ~[] >}

< multilinecomment > SKIP:
{
  "*/" : DEFAULT
| < ~[] >}

TOKEN : /* palavras reservadas */
{
  < IF : "if" >
| < EACH : "each" >
| < ELSE : "else" >
| < PRINT : "print" >}
TOKEN : /* OPERATORS */{  < PLUS : "+" >| < MINUS : "-" >| < MULTIPLY : "*" >| < DIVIDE : "/" >
| < MINOR : "<" >
| < MAJOR : ">" >
| < ATTRIB : "=" >
| < MINOR_EQUAL : "<=" >
| < MAJOR_EQUAL : "=>" >
| < EQUALS : "==" >
| < AND : "&&" >
| < OR : "||" >
| < LIST : "~" >}
TOKEN : /* simbolos especiais */
{
  < LPAREN : "(" >
| < RPAREN : ")" >
| < LBRACE : "{" >
| < RBRACE : "}" >
| < LBRACKET : "[" >
| < RBRACKET : "]" >
| < SEMICOLON : ";" >
| < COMMA : "," >
| < DOT : "." >
| < END_CMD : "!" > }
TOKEN :{
  < INT_CONSTANT : (
    (["0"-"9"] (["0"-"9"])*) |
    (["0"-"7"] (["0"-"7"])* ["o","O"]) |
    (["0"-"9"] (["0"-"7", "A"-"F", "a"-"f"])* ["h","H"]) |
    (["0"-"1"] (["0"-"1"])* ["b","B"]) ) >
| < STRING : "\""(~["\"", "\n", "\r"])* "\"" >| < #DIGIT : [ "0"-"9" ] >
| < #LETTER : ["A"-"Z"] | ["a"-"z"] >
| < VAR : < LETTER > ( < DIGIT > | < LETTER > ) * >
| < FLOAT : < DIGIT >(< DOT >< DIGIT >)* >}
int program() throws Exception:{
  	RecoverySet g = new RecoverySet ( EOF );}
{
	try  {
	  	  calc(g){return 1;} 
	 	| vars()    	< END_CMD > 
   		| list(g)		< END_CMD >
   		| IfElse(g)
   		| each(g)
   		| < EOF >{return 0;}
  	} catch ( ParseException e ) {
		consumeUntil ( g, e, "calc" );
		getNextToken();
  	}}

void list(RecoverySet g) throws Exception:{}
{
  < LIST >
  	< LPAREN >
  		try  		{
  		  	(vars() < SEMICOLON >)+ |
  			(< INT_CONSTANT > < SEMICOLON >)+ |
  			(< STRING > < SEMICOLON >)+  		} catch(ParseException e)  		{
  		  consumeUntil(g, e, "list");  		}
  		
	< RPAREN >}

void IfElse(RecoverySet g) throws Exception:{}
{
  < IF > expression(g) ifBlock(g)
  < ELSE > elseBlock(g)
  	}

void expression(RecoverySet g) throws Exception:
{}
{
	< LPAREN >
		try		{
		  	(< INT_CONSTANT > | < STRING > | vars() (< AND > | < OR >)+ < INT_CONSTANT > | < STRING > | vars())+		}catch(ParseException e)		{
		  	consumeUntil(g, e, "expression");		}
  	< RPAREN >}

void ifBlock(RecoverySet g) throws Exception:{}{
	< LBRACE >
		try		{
		 	(vars())+ < END_CMD >		}catch(ParseException e)		{
		  	consumeUntil(g, e, "ifBlock");		}
  	< RBRACE >}

void elseBlock(RecoverySet g) throws Exception:
{}
{
	< LBRACE >
		try		{
		  	(vars())+ < END_CMD >		}catch(ParseException e)		{
		  	consumeUntil(g, e, "elseBlock");		}
  	< RBRACE >}

void each(RecoverySet g) throws Exception:{}
{
	< EACH > expression(g) eachBlock(g)}

void eachBlock(RecoverySet g) throws Exception:{}
{
	< LBRACE >
		try		{
		 	(vars())* |
			(IfElse())*		}catch(ParseException e)		{
		  	consumeUntil(g, e, "eachBlock");		}
		
	< RBRACE >}

void calc (RecoverySet f) throws Exception :
{ double a = 0;
  RecoverySet g = First.calc.union ( f );
}
{
  try  {
    	vars()    	< END_CMD > 
   		| a = sum() < END_CMD > { mostrarResult( a ); }
  } catch ( ParseException e ) {
		consumeUntil ( g, e, "calc" );
		getNextToken();
  }  
}

// Declarar ou alterar o valor de variáveis
void vars() throws Exception : { Token var; double a=0; }
{
  var = < VAR > < ATTRIB > a=sum()
  {
    tbl.put ( var.image, new Float(a) );
    System.out.println ( "Variável ["+var.image+"] criada/modificada!" );
    return;
  }
}

float sum()  throws Exception : { float a=0, b=0; Token tk; }
{
  a = term()
  (
    (
      tk = < PLUS >
    | tk = < MINUS >
    )
    b = term()
    {
      if (tk.image=="+")
        a+=b;
      else
        a-=b;
    }        
  )*
  { return a; }
}

float term()  throws Exception : { float a=0, b=0; Token tk; }
{
  a = unary()
  (
    (
      tk = < MULTIPLY >
    | tk = < DIVIDE >
    )
    b = unary()
    {
       if (tk.image=="*")
        a*=b;
      else
        a/=b;
    }
  )*
  { return a; }   
}

float unary()  throws Exception :
{float a=0; }
{
  < MINUS > a=element() { return -a; }
| a=element() { return a; }
}

float element() throws Exception : 
{
  Token tk; float a=0;
}
{
     tk = < INT_CONSTANT > { return Integer.parseInt ( tk.image ); }
   | tk = < FLOAT >  { return Float.parseFloat ( tk.image ); }
   | tk = < VAR >
   {
      if (tbl.containsKey(tk.image))
        return ((Float)tbl.get(tk.image)).floatValue();
      throw new ParseException (
        "Variável ["+ tk.image + "] não localizada!"
      + " Linha: " + tk.beginLine + ", Coluna: "+ tk.beginColumn );
   }
   | "(" a = sum() ")" { return a; }
}