/**
 * JavaCC template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */options{  JDK_VERSION = "1.5";  static = false;
  LOOKAHEAD = 2;
  DEBUG_PARSER = false;}PARSER_BEGIN(RubyLikeGrammar)package br.unioeste.compiler.rubylike;

import javax.swing.JTextArea;
import java.io.*;
import java.util.*;
import br.unioeste.compiler.recovery.*;

public class RubyLikeGrammar{
    int contParseError; // Contador de erros sintáticos
    boolean debug_recovery; // Controla a verbose de recuperação de erros
	JTextArea erros;
	
    Hashtable tbl = new Hashtable ();

    public void compilar ( boolean debug_as, boolean debug_recovery, JTextArea errorArea)  {
	this.erros = errorArea;
    this.debug_recovery = debug_recovery;    
    if (!debug_as) this.disable_tracing();

    int b=1;
    while (b==1) {
      try {
        b = this.program();
        switch (b) {
          case 0 :  erros.append("Goodbye.\n");
                    break;
          case 1 :  erros.append("OK.\n");
                    break;
          default : break;
        }
      }	        
      catch (Exception e) {
        erros.append("Oops.\n");
        erros.append(e.getMessage()+ "\n");
        break;
      }
    }
  }
    public static void main(String args []) throws ParseException  {
    boolean debug_as = true;
    boolean debug_recovery = true;
    RubyLikeGrammar parser = new RubyLikeGrammar(System.in);

    parser.debug_recovery = debug_recovery;
    
    if (!debug_as) parser.disable_tracing();
        int b=1;
    while (b==1) {
      System.out.println("Lendo da entrada padrão...");
      System.out.print("Expressão \"1+(2+3)*4;\" ou atribuição :");
      try {
        b = parser.program();
        switch (b) {
          case 0 :  System.out.println("Goodbye.");
                    break;
          case 1 :  System.out.println("OK.");
                    break;
          default : break;
        }
      }
      catch (ParseException e) {
        System.out.println("NOK.");
        System.out.println(e.getMessage());
        parser.ReInit(System.in);
      }
      catch (Exception e) {
        System.out.println("NOK.");
        System.out.println(e.getMessage());
        parser.ReInit(System.in);
      }
      catch (Error e) {
        System.out.println("Oops.");
        System.out.println(e.getMessage());
        break;
      }
    }  }

  void mostrarResult ( double a )
  {
 	//this.erros.append ( Double.toString ( a ) );
  } 

  // Relaciona o indice de um token com seu nome
  static public String im ( int x ) {
    int k;
    String s;
    s = tokenImage[x];
    k = s.lastIndexOf ( "\"");
    try {
      s = s.substring ( 1, k );
    } catch ( StringIndexOutOfBoundsException e ) { }
    return s;
  }

  boolean eof; // Variável que indica se EOF foi alcançado
  // O método abaixo consome os tokens até alcançar um que pertença
  // ao conjunto de resincronização
  void consumeUntil ( RecoverySet g,
                      ParseException e,
                      String met ) throws ParseEOFException, ParseException  {
     Token tok;
     eof=false; // FIXME
     if (debug_recovery) { // Informação sobre a recuperação
       erros.append("");
       erros.append( "*** " + met + " *** ");
       erros.append( " Syncronizing Set: "+ g );
     }
     if (g==null) throw e; // se o conjunto de recuperação é null, propaga a exceção

     tok = getToken ( 1 ); // pega o token atual
     while (!eof) {
       if ( g.contains ( tok.kind ) ) {
         if ( debug_recovery )
           erros.append( " Found syncronizing token: " + im (tok.kind));
         break;
       }
       if (debug_recovery)
         erros.append( " Ignorando token "+ im ( tok.kind));
       getNextToken();
       tok = getToken(1);
       if (tok.kind==EOF && !g.contains(EOF) )
         eof = true;
     }
     System.out.println ( e.getMessage());
     contParseError++;
     if ( eof ) throw new ParseException ( "EOF found prematurely.");
   }
   }PARSER_END(RubyLikeGrammar)SKIP :{  " "| "\r"| "\t"| "\n"
| "\f"
| "#" : singlelinecomment
| "/*" : multilinecomment}
< singlelinecomment > SKIP :
{
  < ["\n","\r"] > : DEFAULT
| < ~[] >}

< multilinecomment > SKIP:
{
  "*/" : DEFAULT
| < ~[] >}

TOKEN : /* palavras reservadas */
{
  < IF : "if" >
| < EACH : "each" >
| < ELSE : "else" >
| < PRINT : "print" >}
TOKEN : /* OPERATORS */{  < PLUS : "+" >| < MINUS : "-" >| < MULTIPLY : "*" >| < DIVIDE : "/" >
| < MINOR : "<" >
| < MAJOR : ">" >
| < ATTRIB : "=" >
| < MINOR_EQUAL : "<=" >
| < MAJOR_EQUAL : "=>" >
| < EQUALS : "==" >
| < AND : "&&" >
| < OR : "||" >
| < LIST : "~" >
| < SETA : "->" >}
TOKEN : /* simbolos especiais */
{
  < LPAREN : "(" >
| < RPAREN : ")" >
| < LBRACE : "{" >
| < RBRACE : "}" >
| < LBRACKET : "[" >
| < RBRACKET : "]" >
| < SEMICOLON : ";" >
| < COMMA : "," >
| < DOT : "." >
| < END_CMD : "!" > }
TOKEN :{
  < INT_CONSTANT : (
    (["0"-"9"] (["0"-"9"])*) |
    (["0"-"7"] (["0"-"7"])* ["o","O"]) |
    (["0"-"9"] (["0"-"7", "A"-"F", "a"-"f"])* ["h","H"]) |
    (["0"-"1"] (["0"-"1"])* ["b","B"]) ) >
| < STRING : "\""(~["\"", "\n", "\r"])* "\"" >| < #DIGIT : [ "0"-"9" ] >
| < #LETTER : ["A"-"Z"] | ["a"-"z"] >
| < VAR : < LETTER > ( < DIGIT > | < LETTER > ) * >
| < FLOAT : < DIGIT >(< DOT >< DIGIT >)* >}
int program() throws Exception:{
  	RecoverySet g = new RecoverySet ( EOF );}
{
	try  {
	 	calc(g){return 1;}
   		| < EOF >{return 0;}
  	} catch ( ParseException e ) {
		consumeUntil ( g, e, "calc" );
		getNextToken();
  	}}

Object list() throws Exception:{
  	Token t; List<Object> lista = new ArrayList<Object>();}
{
  < LIST >
  	< LPAREN >
  		(t = < INT_CONSTANT > | t = < STRING > | t = < FLOAT > | t = < VAR >)
  		{
  	  		System.out.println(t.image);
   			lista.add(t.image);
  		}
  		("," t = < INT_CONSTANT > | t = < STRING > | t = < FLOAT > | t = < VAR >)*
  		{
  	  		System.out.println(t.image);
   			lista.add(t.image);
  		}
  		
  	< RPAREN >
  	
  	
  {return lista;}}

void IfElse(RecoverySet g) throws Exception:{
 	boolean cond = false;}
{
  < IF > < LPAREN > expressionLogical(g) < RPAREN > < LBRACE > ifBlock(g) < RBRACE > < ELSE > < LBRACE > elseBlock(g) < RBRACE > |  < IF > < LPAREN > expressionLogical(g) < RPAREN > < LBRACE > ifBlock(g) < RBRACE >    }

void expressionLogical(RecoverySet g) throws Exception:
{}
{
	(< VAR > opExpression() < VAR >) |	(< INT_CONSTANT > opExpression() < INT_CONSTANT >) |
	(< VAR > opExpression() < INT_CONSTANT >) |	(< INT_CONSTANT > opExpression() < VAR >)
	}

void opExpression():{}
{
 	< AND >
 	| < OR >
 	| < MINOR >
 	| < MAJOR >
 	| < EQUALS >
 	| < MINOR_EQUAL >
 	| < MAJOR_EQUAL >}
void ifBlock(RecoverySet g) throws Exception:{}{
	try	{
		 (vars(null))* < END_CMD >
		| (IfElse(g))* < END_CMD >	}catch(ParseException e)	{
		consumeUntil(g, e, "ifBlock");	}}

void elseBlock(RecoverySet g) throws Exception:
{}
{
	try	{
		(vars(null))* < END_CMD >
		| (IfElse(g))* < END_CMD >	}catch(ParseException e)	{
		consumeUntil(g, e, "elseBlock");	}}

void each(RecoverySet g) throws Exception:{}
{
	< EACH > < LPAREN > eachExp(g) < RPAREN > < LBRACE > eachBlock(g) < RBRACE >}

void eachExp(RecoverySet g) throws Exception:
{}
{
  try  {
	< VAR > < SETA > < VAR >
  }catch(ParseException e)  {
    consumeUntil(g, e, "eachExp");  }}

void eachBlock(RecoverySet g) throws Exception:{}
{
	try	{
		(vars(null))* < END_CMD >
		| (IfElse(g))* < END_CMD >	}catch(ParseException e)	{
		consumeUntil(g, e, "eachBlock");	}}

void print(Hashtable local):{
  Token token; List<Object> list;}
{
	< PRINT > ( token = < VAR > | token = < INT_CONSTANT > | token = < STRING >)+
	{
	  if(local != null && local.containsKey(token.image))	  {
	    if(local.get(token.image) instanceof ArrayList)	    {
	      list = (ArrayList<Object>) local.get(token.image);
	      for(int i = 0; i < list.size(); i++)
	        erros.append(list.get(i).toString() + " ");
	      erros.append("\n");	    }
	    else
	    	erros.append(local.get(token.image).toString() + "\n");	  }
	  else if(tbl.containsKey(token.image))
	  {
	    if(tbl.get(token.image) instanceof ArrayList)	    {
	      list = (ArrayList<Object>) tbl.get(token.image);
	      for(int i = 0; i < list.size(); i++)
	        erros.append(list.get(i).toString() + " ");
	      erros.append("\n");	    }
	    else
	    	erros.append(tbl.get(token.image).toString() + "\n");	  }
	  	
	  else
	  	erros.append(token.image + "\n");	} }

void calc (RecoverySet f) throws Exception :
{ double a = 0;
  RecoverySet g = First.calc.union ( f );
}
{
  try  {
	each(g) 		< END_CMD >
	| IfElse(g)		< END_CMD >
    | vars(null)    < END_CMD >
    | print(null)	< END_CMD >	
  } catch ( ParseException e ) {
	consumeUntil ( g, e, "calc" );
	getNextToken();
  }  
}

// Declarar ou alterar o valor de variáveis
Object vars(Hashtable local) throws Exception : { Token var; Object a; }
{
  var = < VAR > < ATTRIB > (a = list() |  a = < STRING > | a = sum(local))
  {
    if(local == null)
    	tbl.put ( var.image, a );
   	else
   		local.put(var.image, a);
   		
    erros.append( "Variável ["+var.image+"] criada/modificada!" + "\n" );
    erros.append("Conteúdo da variável: " + a + "\n");
    return var;
  }
}

Object sum(Hashtable local)  throws Exception : { Object a, b; Token tk; Double a1, b1; }
{
  a = term(local)
  (
    (
      tk = < PLUS >
    | tk = < MINUS >
    )
    b = term(local)
    {
      if (tk.image=="+")      {
       		a1 = Double.parseDouble(a.toString());
         	b1 = Double.parseDouble(b.toString());
       		a1 += b1;
       		a = a1;      }
      else      {
       		a1 = Double.parseDouble(a.toString());
         	b1 = Double.parseDouble(b.toString());
       		a1 -= b1;
       		b = a1;      }
    }        
  )*
  { return a; }
}

Object term(Hashtable local)  throws Exception : { Object a, b; Token tk; Double a1, b1;}
{
  a = unary(local)
  (
    (
      tk = < MULTIPLY >
    | tk = < DIVIDE >
    )
    b = unary(local)
    {
       if (tk.image=="*")       {
         	a1 = Double.parseDouble(a.toString());
         	b1 = Double.parseDouble(b.toString());
         	a1 *= b1;
         	a = a1;       }
      else
      {
       		a1 = Double.parseDouble(a.toString());
         	b1 = Double.parseDouble(b.toString());
         	a1 /= b1;
         	a = a1;      }
    }
  )*
  { return a; }   
}

Object unary(Hashtable local)  throws Exception :
{Object a; }
{
  < MINUS > a=element(local) { return -(Double)a; }
| a=element(local) { return a; }
}

Object element(Hashtable local) throws Exception : 
{
  Token tk; Object a=0;
}
{
     tk = < INT_CONSTANT > { return tk.image ; }
   | tk = < FLOAT >  { return tk.image; }
   | tk = < VAR >
   {
      if(local != null && local.containsKey(tk.image))      	return local.get(tk.image);
      	
      if (tbl.containsKey(tk.image))
        return (tbl.get(tk.image));
        
      throw new ParseException (
        "Variável ["+ tk.image + "] não localizada!"
      + " Linha: " + tk.beginLine + ", Coluna: "+ tk.beginColumn );

      erros.append("Variável ["+ tk.image + "] não localizada!" + "\n");
      erros.append(" Linha: " + tk.beginLine + ", Coluna: "+ tk.beginColumn + "\n");
   }
   | "(" a = sum(local) ")" { return a; }
}