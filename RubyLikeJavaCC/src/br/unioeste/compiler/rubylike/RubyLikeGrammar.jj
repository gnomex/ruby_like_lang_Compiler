/**
 * JavaCC template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */options{  JDK_VERSION = "1.5";  static = true;}PARSER_BEGIN(RubyLikeGrammar)package br.unioeste.compiler.rubylike;

public class RubyLikeGrammar{  public static void main(String args []) throws ParseException  {    RubyLikeGrammar parser = new RubyLikeGrammar(System.in);    while (true)    {      System.out.println("Reading from standard input...");      System.out.print("Enter an expression like \"1+(2+3)*4;\" :");      try      {        switch (RubyLikeGrammar.one_line())        {          case 0 :           System.out.println("OK.");          break;          case 1 :           System.out.println("Goodbye.");          break;          default :           break;        }      }      catch (Exception e)      {        System.out.println("NOK.");        System.out.println(e.getMessage());        RubyLikeGrammar.ReInit(System.in);      }      catch (Error e)      {        System.out.println("Oops.");        System.out.println(e.getMessage());        break;      }    }  }}PARSER_END(RubyLikeGrammar)SKIP :{  " "| "\r"| "\t"| "\n"}TOKEN : /* OPERATORS */{  < PLUS : "+" >| < MINUS : "-" >| < MULTIPLY : "*" >| < DIVIDE : "/" >
| < MINOR : "<" >
| < MAJOR : ">" >
| < ATTRIB : "=" >
| < MINOR_EQUAL : "<=" >
| < MAJOR_EQUAL : "=>" >
| < EQUALS : "==" >
| < AND : "&&" >
| < OR : "||" >
| < LIST : ["~"] >}TOKEN :{  < INTEGER : (< DIGIT >)+ >| < #DIGIT : [ "0"-"9" ] >
| < #LETTER : ["A"-"Z"] | ["a"-"z"] >
| < #SPACE : [" "] >
| < VAR : < LETTER > ( < DIGIT > | < LETTER > ) * >
| < START_BLOCK_EXP : ["("] >
| < END_BLOC_EXP : [")"] >
| < START_BLOCK_CMD : ["{"] >
| < END_BLOCK_CMD: ["}"] >
| < END_CMD : ["!"] >
| < FLOAT : < DIGIT >("."< DIGIT >)* >
| < STRING : ["\""] (< LETTER > | < SPACE > | < DIGIT >)+ ["\""] >}int one_line() :{}{  sum() ";"  {    return 0;  }| ";"  {    return 1;  }}void sum() :{}{  term()  (    (      < PLUS >    | < MINUS >    )    term()  )*}void term() :{}{  unary()  (    (      < MULTIPLY >    | < DIVIDE >    )    unary()  )*}void unary() :{}{  < MINUS > element()| element()}void element() :{}{  < INTEGER >| "(" sum() ")"}
